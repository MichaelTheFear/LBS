function

pushq %rbp
movq %rsp,%rbp
subq $40,%rsp
movq %rdi,-48(%rbp) -> argumento passado para a stack para salvar

{0x55,0x48,0x89,0xe5,0x48,
0x83,0xec,0x30,0x48,
0x89,0x7d,0xd0}
========================

end 

leave
ret

{0xc9,0xc3}

========================

ret YY

retorno de variavel

movq -X(%rbp),%rax

{0x48,0x8b,0x45,0xd8} -> V = 0
{0x48,0x8b,0x45,0xe0} -> V = 1
{0x48,0x8b,0x45,0xe8} -> V = 2
{0x48,0x8b,0x45,0xf0} -> V = 3
{0x48,0x8b,0x45,0xf8} -> V = 4

{0x48,0x8b,0x45,0xd8+(8*V)}

retorno de constante

movq $YY,%rax

{0x48,0xc7,0xc0,YY,YY,YY,YY}

retorno de aritimetica

movq %r12,%rax

{0x4c,0x89,0xe0}

========================

assigment de variavel para variavel

Qualquer calculo sera colocado diretamente em %r12
entao dar assigment de um calculo seria so mover o resultado de 
%r12 para alguma variavel

V = . . .

movq %r12,-X(%rbp)


{0x4c,0x89,0x65,0xd0} -> p0
{0x4c,0x89,0x65,0xd8} -> V = 0
{0x4c,0x89,0x65,0xe0} -> V = 1
{0x4c,0x89,0x65,0xe8} -> V = 2
{0x4c,0x89,0x65,0xf0} -> V = 3
{0x4c,0x89,0x65,0xf8} -> V = 4

{0x4c,0x89,0x65,0xd8+(8*V)}


assigment de constante para variavel

movq $YY,-X(%rbp)

{0x48,0xc7,0x45,0xd8,YY,YY,YY,YY} -> V = 0
{0x48,0xc7,0x45,0xe0,YY,YY,YY,YY} -> V = 1
{0x48,0xc7,0x45,0xe8,YY,YY,YY,YY} -> V = 2
{0x48,0xc7,0x45,0xf0,YY,YY,YY,YY} -> V = 3
{0x48,0xc7,0x45,0xf8,YY,YY,YY,YY} -> V = 4

V = $YY

{0x48,0xc7,0x45,0xd8+(8*V),YY,YY,YY,YY}

V' = V''

movq -X''(%rbp),%r12
movq %r12,-X'(%rbp)

movq -X''(%rbp),%r12
{0x4c,0x8b,0x65,0xd8} -> V'' = 0
{0x4c,0x8b,0x65,0xe0} -> V'' = 1
{0x4c,0x8b,0x65,0xe8} -> V'' = 2 
{0x4c,0x8b,0x65,0xf0} -> V'' = 3
{0x4c,0x8b,0x65,0xf8} -> V'' = 4

{0x4c,0x8b,0x65,0xd8+(8*V'')}

movq %r12,-X'(%rbp)
{0x4c,0x89,0x65,0xd8+(8*V)}

=========================
var + const

movq $YY,%r12
addq -X(%rbp),%r12

{0x49,0xc7,0xc4,YY,YY,YY,YY} -> YY
{0x4c,0x03,0x65,0xd0} -> p0
{0x4c,0x03,0x65,0xd8} -> V = 0
{0x4c,0x03,0x65,0xe0} -> V = 1
{0x4c,0x03,0x65,0xe8} -> V = 2
{0x4c,0x03,0x65,0xf0} -> V = 3
{0x4c,0x03,0x65,0xf8} -> V = 4

{0x49,0xc7,0xc4,YY,YY,YY,YY,0x4c,0x03,0x65,0xd8+(8*V)}

var + var

tabela linha 87
e ultima tabela

movq -X(%rbp),%r12
addq -X'(%rbp),%r12

const + const

movq $Y1,%r12 -> tabela linha 105
addq $Y2,%r12

addq $Y2,%r12
{0x49,0x81,0xc4,YY,YY,YY,YY}

====================================
var - var

seguem as mesmas regras de soma

movq -X'(%rbp),%r12
subq -X(%rbp),%r12


{0x4c,0x2b,0x65,0xd0} -> p0
{0x4c,0x2b,0x65,0xd8} -> V = 0
{0x4c,0x2b,0x65,0xe0} -> V = 1
{0x4c,0x2b,0x65,0xe8} -> V = 2
{0x4c,0x2b,0x65,0xf0} -> V = 3
{0x4c,0x2b,0x65,0xf8} -> V = 4

subq -X'(%rbp),%r12
{0x4c,0x2b,0x65,0xd8+(8*V)}

subq $YY,%r12
{0x49,0x81,0xec,YY,YY,YY,YY}

var - const

{0x48,0x2b,0x04,0x25,YY,YY,YY,YY}

const - const , mesmo de soma

====================================
var * var

imul -X(%rbp),%r12
{0x4c,0x0f,0xaf,0x65,0xd0} -> p0
{0x4c,0x0f,0xaf,0x65,0xd8} -> V = 0
{0x4c,0x0f,0xaf,0x65,0xe0} -> V = 1
{0x4c,0x0f,0xaf,0x65,0xe8} -> V = 2
{0x4c,0x0f,0xaf,0x65,0xf0} -> V = 3
{0x4c,0x0f,0xaf,0x65,0xf8} -> V = 4

reg * const

imul $YY,%r12

{0x4d,0x69,0xe4,YY,YY,YY,YY}

FALTA COM ARGUMENTO

====================================
call function N arg

parte 1: ajustar argumento
parte 2: calcular o endereço da função
parte 3: chamar a função
parte 4: ajustar para onde vai o resultado da função
parte 5: reajustar o argumento apos a chamada da função


parte 1:

ajustar argumento com registro

movq -X(%rbp),%rdi

{0x48,0x8b,0x7d,0xd8} -> V = 0
{0x48,0x8b,0x7d,0xe0} -> V = 1
{0x48,0x8b,0x7d,0xe8} -> V = 2
{0x48,0x8b,0x7d,0xf0} -> V = 3
{0x48,0x8b,0x7d,0xf8} -> V = 4
{0x48,0x8b,0x7d,0xd0} -> p0 

{0x48,0x8b,0x7d,0xd8+(8*V)} -> para V
{0x48,0x8b,0x7d,0xd0} -> p0


ajustar argumento com constante

movq $YY,%rdi

{0x48,0xc7,0xc7,YY,YY,YY,YY}


parte 2:
Para isso teremos um array onde cada indice equivale ao
numero de bytes des de 0 ao numero de bytes da função
se diminuirmos indice_func_atual - indice_func_para_chamar
obtemos o numero YY

parte 3: chama a função com o endereço

{0xe8,YY,YY,YY,YY} onde YY é o endereço da função

parte 4:

movq %rax,-X(%rbp)

{0x48,0x89,0x44,0x24,0xd8+(8*V)}

==========================
zret XX YY

parte 1: mover item de comparação de diferente de zero a um registro
parte 2: chamar comparação
item != 0: ir para label de continuação da função
item == 0: mover valor de retorno e retornar função

movq -X(%rbp),%r12
tabela linha 88

cmp $0,%r12
{0x49,0x83,0xfc,0x00}

jne label_continuação
caso YY seja um registro ou p0
{0x75,0x06}

caso YY seja uma constante
{0x75,0x09}

mov YY, %rax (linha 25)
leave
ret

entao o codigo em assembly fica:
movq -X(%rbp),%r12
cmp $0,%r12
jne label_continuação
mov YY, %rax 
leave
ret


==========================================

O que falta falar:

a primeira função tem q ser a ultima a ser adicionada
ao array, tem duas formas de fazermos isso:

1- lemos todas as funções, e damos shift na ultima

2- lemos todas as funções e viramos o array de funções

3- Sandbox, basicamente fazemos uma função que sempre
estara no inicio para chamar a ultima função

iremos com a 3, pois e mais facil de implementar,
todos os programas de LBS começaram com

pushq %rbp
movq %rsp,%rbp
call lastFunction
leave ret