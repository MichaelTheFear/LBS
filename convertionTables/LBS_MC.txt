function

pushq %rbp
movq %rsp, %rbp

{0x55,0x48,0x89,0xe5}

========================

end 

popq %rbp
ret

{0x53,0xc3}

========================

ret YY

mov YY, %rax

se YY for registro:

caso epecial de um retorno ser alguma
resolução de conta = {0x48,0x89,0xc0}
v0 = {0x48,0x89,0xc8}
v1 = {0x48,0x89,0xd0}
v2 = {0x48,0x89,0xf0}
p0 = {0x48,0x89,0xf8}
v3 = {0x4c,0x89,0xc0}
v4 = {0x4c,0x89,0xc8}

se YY for constante:

{0x48,0x8b,0x04,0x25,YY,YY,YY,YY}

========================

assigment de registro para registro


mov %rax,%rcx
mov %rax,%rdx
mov %rax,%rsi
mov %rax,%rdi
mov %rax,%r8
mov %rax,%r9

v0 = {0x48,0x89,0xc1}
v1 = {0x48,0x89,0xc2}
v2 = {0x48,0x89,0xc6}
p0 = {0x48,0x89,0xc7}
v3 = {0x49,0x89,0xc0}
v4 = {0x49,0x89,0xc1}

assigment de constante para registro

mov 0xFFF,%rax
mov 0xFFF,%rcx
mov 0xFFF,%rdx
mov 0xFFF,%rsi
mov 0xFFF,%rdi
mov 0xFFF,%r8
mov 0xFFF,%r9

ret = {0x48,0x8b,0x04,0x25,YY,YY,YY,YY}
v0 = {0x48,0x8b,0x0c,0x25,YY,YY,YY,YY}
v1 = {0x48,0x8b,0x14,0x25,YY,YY,YY,YY}
v2 = {0x48,0x8b,0x34,0x25,YY,YY,YY,YY}
p0 = {0x48,0x8b,0x3c,0x25,YY,YY,YY,YY}
v3 = {0x4c,0x8b,0x04,0x25,YY,YY,YY,YY}
v4 = {0x4c,0x8b,0x0c,0x25,YY,YY,YY,YY}

=========================
reg + const


mov XX,%rax
add $YY,%rax

para isso usamos a mesma tabela do ret para passar o registro da conta
para %rax
(linha 25)

e depois somamos a constante ao registro de rax

{0x48,0x03,0x04,0x25,YY,YY,YY,YY}

v0 + $2 ent ficaria algo como:

mov %rax,%rcx
mov $2,%rax

{0x48,0x89,0xc8,0x48,0x03,0x04,0x25,0x02,0x00,0x00,0x00}

juntando com assigment ficaria:

mov %rax,%rcx
add $2,%rax
mov %rax,%rdx

v1 = v0 + $2
{0x48,0x89,0xc8,0x48,0x03,0x04,0x25,0x02,0x00,0x00,0x00,0x48,0x89,0xc2}


reg + reg

mov XX,%rax
add %YY,%rax

mesma coisa que o anterior so que agora com a tabela de registros
v0 = {0x48,0x01,0xc8}
v1 = {0x48,0x01,0xd0}
v2 = {0x48,0x01,0xf0}
p0 = {0x48,0x01,0xf8}
r8 = {0x4c,0x01,0xc0}
r9 = {0x4c,0x01,0xc8}

entao v1 = v0 + v1:

mov XX, %rax
add %rcx,%rax
mov %rax,%rdx

{0x48,0x89,0xc8,0x48,0x01,0xc8,0x48,0x89,0xc2}

FALTA: CONSTANTE + CONSTANTE

====================================
reg - reg

seguem as mesmas regras de soma

v0 = {0x48,0x29,0xc8}
v1 = {0x48,0x29,0xd0}
v2 = {0x48,0x29,0xf0}
p0 = {0x48,0x29,0xf8}
v3 = {0x4c,0x29,0xc0}
v4 = {0x4c,0x29,0xc8}

reg - const

{0x48,0x2b,0x04,0x25,YY,YY,YY,YY}

FALTA: CONSTANTE - CONSTANTE

====================================
reg * reg

v0 = {0x48,0x0f,0xaf,0xc1}
v1 = {0x48,0x0f,0xaf,0xc2}
v2 = {0x48,0x0f,0xaf,0xc6}
p0 = {0x48,0x0f,0xaf,0xc7}
v3 = {0x49,0x0f,0xaf,0xc0}
v4 = {0x49,0x0f,0xaf,0xc1}

reg * const

{0x48,0x0f,0xaf,0x04,0x25,YY,YY,YY,YY}

====================================
call function N arg

parte 1: ajustar argumento
parte 2: calcular o endereço da função
parte 3: chamar a função
parte 4: ajustar para onde vai o resultado da função
parte 5: reajustar o argumento apos a chamada da função


parte 1:
ajustar argumento com registro

ret = {0x48,0x89,0xc7}
v0 = {0x48,0x89,0xcf}
v1 = {0x48,0x89,0xd7}
v2 = {0x48,0x89,0xf7}
p0 = {0x48,0x89,0xff}
v3 = {0x4c,0x89,0xc7}
v4 = {0x4c,0x89,0xcf}

ajustar argumento com constante

{0x48,0xc7,0xc7,YY,YY,YY,YY}

parte 2:
Para isso teremos um array onde cada indice equivale ao
numero de bytes des de 0 ao numero de bytes da função
se diminuirmos indice_func_atual - indice_func_para_chamar
obtemos o numero YY

parte 3: chama a função com o endereço

{0xe8,YY,YY,YY,YY} onde YY é o endereço da função

parte 4:
para isso usamos a tabela de assigment para ajustar o resultado
